import yt_dlp
import uuid
import os
import subprocess
import json

def download_and_process_video(url: str) -> str:
    """
    Downloads video from a URL.
    Tries to find a pre-merged MP4 to avoid requiring FFmpeg for merging.
    """
    filename = f"/tmp/{uuid.uuid4()}.mp4"
    
    # Ensure the temp directory exists
    os.makedirs("/tmp", exist_ok=True)
    
    ydl_opts = {
        #prefer mp4, but take anything best if mp4 fails
        'format': 'best[ext=mp4]/best',
        'outtmpl': filename,
        'noplaylist': True,
        'quiet': True,
        'overwrites': True,
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])
        return filename
    except Exception as e:
        if os.path.exists(filename):
            os.remove(filename)
        raise RuntimeError(f"Video download failed: {str(e)}")

async def analyze_text_logic(text_content: str):
    """
    Analyzes raw text for AI generation patterns.
    """
    # cache check
    text_id = hashlib.md5(text_content.encode()).hexdigest()
    
    if cached := cache.get(text_id):
        print(f"âš¡ Text Cache HIT")
        return json.loads(cached)

    print(f"ðŸ¢ Text Cache MISS. Analyzing...")

    try:
        # gemini analysis
        prompt = """
        You are an AI-Detector. Analyze this text to determine if it was generated by an AI/LLM.
        Look for: overly formal tone, lack of personal anecdote, repetitive sentence structure, and 'hallucination' patterns.

        Return JSON ONLY:
        {
            "Detector_score": int (0-100, where 100 is definitely AI),
            "verdict": "Human" | "AI-Generated" | "Mixed",
            "content_analysis": {
                "writing_style": "Formal/Casual/Robotic",
                "indicators": ["list of specific phrases or patterns found"]
            }
        }
        """

        response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=[prompt, text_content]
        )
        
        # clean JSON
        raw_text = response.text.replace("```json", "").replace("```", "").strip()
        result = json.loads(raw_text)

        # cache result
        cache.setex(text_id, 86400, json.dumps(result))
        return result

    except Exception as e:
        print(f"Text Error: {e}")
        return {
            "Detector_score": 0, "verdict": "Error",
            "content_analysis": {"error": str(e)}
        }
    
def extract_video_metadata(file_path: str) -> dict:
    """
    Scans video file headers using ffprobe to find:
    1. Encoder Name (Real cameras vs FFmpeg/Lavf)
    2. Duration & Bitrate
    3. Specific AI metadata tags (if present)
    """
    try:
        # run ffprobe to get JSON output of file format
        cmd = [
            "ffprobe", 
            "-v", "quiet", 
            "-print_format", "json", 
            "-show_format", 
            "-show_streams", 
            file_path
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            return {"error": "ffprobe failed"}

        data = json.loads(result.stdout)
        format_info = data.get("format", {})
        tags = format_info.get("tags", {})

        # look for suspicious indicators
        encoder = tags.get("encoder", "Unknown")
        major_brand = tags.get("major_brand", "Unknown")
        
        # logical checks
        is_suspicious = False
        suspicion_reason = []

        # Check  for Generic FFmpeg encoding (common in AI output, but also YouTube)
        if "Lavf" in encoder:
            suspicion_reason.append("Generic Lavf/FFmpeg encoder detected (Could be AI or Web-Re-encoded)")
        
        # Check for Missing Camera Data (Real files usually have 'creation_time', 'location', etc.)
        if "make" not in tags and "model" not in tags:
            suspicion_reason.append("No Camera Manufacturer/Model metadata found")

        return {
            "valid": True,
            "duration": format_info.get("duration"),
            "format": format_info.get("format_name"),
            "encoder": encoder,
            "suspicious_indicators": suspicion_reason,
            "raw_tags": tags # for debugging
        }

    except Exception as e:
        return {"valid": False, "error": str(e)}